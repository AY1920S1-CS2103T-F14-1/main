{
  "questions" : [ {
    "title" : "Two Number Adder",
    "status" : "PASSED",
    "difficulty" : "EASY",
    "isBookmarked" : false,
    "topics" : [ "OTHERS" ],
    "testCases" : [ {
      "input" : "1 2",
      "expectedResult" : "3"
    }, {
      "input" : "100 2",
      "expectedResult" : "102"
    } ],
    "userProgram" : {
      "canonicalName" : "Adder",
      "sourceCode" : "public class Adder { public static void main(String[] args) { } }"
    },
    "description" : "Given an array of integers, return indices of the two numbers such that they add up to a specific target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nExample:\n\nGiven nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1]."
  }, {
    "title" : "Valid Sudoku",
    "status" : "PASSED",
    "difficulty" : "MEDIUM",
    "isBookmarked" : true,
    "topics" : [ "ARRAY", "DYNAMIC_PROGRAMMING", "OTHERS" ],
    "testCases" : [ {
      "input" : "1 2 3 4 5 6 7 8 9",
      "expectedResult" : "True"
    }, {
      "input" : "-1 -1 -1 -1",
      "expectedResult" : "False"
    } ],
    "userProgram" : {
      "canonicalName" : "Sudoku",
      "sourceCode" : "public class Sudoku { public static void main(String[] args) { } }"
    },
    "description" : "Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou may assume no duplicates in the array.\n\nExample 1:\n\nInput: [1,3,5,6], 5\nOutput: 2\nExample 2:\n\nInput: [1,3,5,6], 2\nOutput: 1\nExample 3:\n\nInput: [1,3,5,6], 7\nOutput: 4\nExample 4:\n\nInput: [1,3,5,6], 0\nOutput: 0"
  }, {
    "title" : "Palindrome Number",
    "status" : "PASSED",
    "difficulty" : "EASY",
    "isBookmarked" : true,
    "topics" : [ "RECURSION", "OTHERS" ],
    "testCases" : [ {
      "input" : "12321",
      "expectedResult" : "True"
    }, {
      "input" : "10111",
      "expectedResult" : "False"
    } ],
    "userProgram" : {
      "canonicalName" : "Palindrome",
      "sourceCode" : "public class Palindrome { public static void main(String[] args) { } }"
    },
    "description" : "Given a linked list, determine if it has a cycle in it.\n\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\n\n \n\nExample 1:\n\nInput: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\n\n\nExample 2:\n\nInput: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where tail connects to the first node.\n\n\nExample 3:\n\nInput: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list."
  }, {
    "title" : "Swap nodes in pairs",
    "status" : "NEW",
    "difficulty" : "MEDIUM",
    "isBookmarked" : false,
    "topics" : [ "GRAPH", "DYNAMIC_PROGRAMMING" ],
    "testCases" : [ {
      "input" : "5 12 33 23",
      "expectedResult" : "4132"
    }, {
      "input" : "2 31 01",
      "expectedResult" : "1232"
    } ],
    "userProgram" : {
      "canonicalName" : "NodePairs",
      "sourceCode" : ""
    },
    "description" : "Write an algorithm to determine if a number is \"happy\".\n\nA happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.\n\nExample: \n\nInput: 19\nOutput: true\nExplanation: \n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1"
  }, {
    "title" : "Merge k Sorted Lists",
    "status" : "ATTEMPTED",
    "difficulty" : "HARD",
    "isBookmarked" : false,
    "topics" : [ "LINKED_LIST", "SORTING" ],
    "testCases" : [ {
      "input" : "3 5 3 4 1 99 0 21 34 123 3 21 3 1",
      "expectedResult" : "0 1 3 4 21 34 99 123"
    }, {
      "input" : "1 4 1 2 3 4",
      "expectedResult" : "1 2 3 4"
    } ],
    "userProgram" : {
      "canonicalName" : "Merge",
      "sourceCode" : "public class Merge { public static void main(String[] args) { } }"
    },
    "description" : "Given an array A of positive lengths, return the largest perimeter of a triangle with non-zero area, formed from 3 of these lengths.\n\nIf it is impossible to form any triangle of non-zero area, return 0.\n\n \n\nExample 1:\n\nInput: [2,1,2]\nOutput: 5\nExample 2:\n\nInput: [1,2,1]\nOutput: 0\nExample 3:\n\nInput: [3,2,3,4]\nOutput: 10\nExample 4:\n\nInput: [3,6,2,3]\nOutput: 8\n \n\nNote:\n\n3 <= A.length <= 10000\n1 <= A[i] <= 10^6"
  } ]
}