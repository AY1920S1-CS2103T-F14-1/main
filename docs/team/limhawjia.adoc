= Lim Haw Jia - Project Portfolio
:site-section: AboutUs
:imagesDir: ../images/hj_ppp
:stylesDir: ../stylesheets/

== Project: Duke Academy

Duke Academy is a Java based programming practice application equipped with a wide range of questions related to the field of Data Structures and Algorithms.

== Overview

Duke Academy was built to emulate a Command Line Application where users interact with the GUI by typing commands into a command box.
This decision was made to allow new learners to also familiarize themselves with using a Command Line Interface, an invaluable skill for all programmers.

[.text-center]
.Main GUI of Duke Academy
image::DukeAcademyGUI.png[align="center"]

Duke Academy is an integrated platform with a built-in text editor, an auto-grader and a note-taking feature.
It provides all the tools needed for a good practice session so that its users will never have to tab out to another application.

.Text editor and auto-grader
image::TextEditorAndGrader.png[align="center]

.Note-taking feature
image::NotesFeature.png[align="center"]

DukeAcademy can also be used as a teaching tool by educators as they can set their own questions to be loaded by their students using our very own simplified text file format.

Duke Academy is written in Java, and has about 15 kLoC.

== My Roles and Contributions

The following segment illustrates the different roles and tasks that I have performed for our team in detail.
It also provides a bit of justification for the different choices that I have made pertaining to these roles and tasks.

=== Change underlying architecture to suit our needs - [refactor]

|===
|_Due to the increased complexity of our product, a large part of the existing architecture had to be changed.
Most of the changes can be summarized into the 4 following sections :_
|===

. *Separated Logic component into cohesive parts*

  * What it does : +
  Splits the old Logic interface in AddressBook3 into different interface with their own specialized functions.
  The new interfaces are `CommandLogic`, `QuestionsLogic`, `ProgramSubmissionLogic` and `NotesLogic`. Each interface serves as a facade to facilitate operations pertaining to different aspects of our app.
  * Justification : +
  As the complexity of our app increased, we realized that the functionality of the application can be split into 4 cohesive units. Each unit deals with _commands_, _questions_, _program evaluation_ and  _notes_ respectively. Thus, instead of using a single logic class to encapsulate all of those functionalities, each cohesive unit was made into its own logic class, keeping them loosely coupled.
  This helped to make our codebase more testable and maintainable.

. *Implemented Observer pattern* +

  * What it does : +
  Provides a simple and lightweight observable class that can be customized using Java generics.
  This enables various different components such as the UI to observe changes to the state of the application without introducing them as unnecessary dependencies.
  * Justification : +
  The existing AddressBook3 implementation made use of JavaFX's native ObservableList class to display the list of contacts.
  However, as we needed to observe other objects, we realized that JavaFX's native Observable class was slightly too over-engineered for our use cases.

. *Refactor Command pattern*

  * What it does : +
  Change the implementation of the Command pattern to be more flexible. The `execute()` function of the `Ccommand` interface no longer takes in a `Model`. Argument parsing is also handled by the `Command` itself.
  Open-closed principle is maintained by requiring commands to be registered into the `CommandLogic` with a `Supplier` functional interface. The https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Supplier.html[`Supplier`] is in charge of injecting different dependencies that various commands need.

  * Justification : +
  The previous implementation of the `Command` in AddressBook3 was inflexible in the sense that the execution of each command requires a `Model`. The command arguments also had to follow a fixed format. However, as the complexity of our application grew, our commands started to vary. Most Commands no longer relied on a `Model` for execution and started to have their own unique sets of argument parsing rules.

=== Program evaluation feature - [feature]
* What it does : +
  Allows users' solutions to be automatically graded by our application. The user's solution is evaluated against test cases specified in the `Question` class.
* Justification : +
  It is difficult to come up with your own test cases to evaluate your solutions whenever you attempt programming questions. It is also very cumbersome to run each test case manually. Allowing users to automatically have their solutions evaluated will allow them to focus more on their learning.
* Highlights :
** Compile and runtime errors are also displayed to the user in the event that they occur so that user's are able to learn from their mistakes.
** A _Time Limit Exceeded_ error is displayed if the user's program takes too long to complete. This will enable users to know if their solutions are properly optimized.

=== Note-taking feature - [feature]
* What it does : +
  Allows users to record notes in the form of text or a simple sketch.

* Justification : +
  Being able to pen down ideas is extremely useful when coming up with solutions to programming questions. Furthermore, being able to take notes for future reference will help to reinforce the user's learning.

* Highlights : +
  In addition to taking notes in the form of text, user's are also able to sketch their ideas within a a sketch pad and have them saved for future reference. This is particularly useful when dealing with data structures.

=== Tabs - [design]
* What it does  : +
  Splits the various functions of the application, _browsing and viewing of questions_, _attempting of questions and evaluation of results_, _note-taking_, into individual tabs.

* Justification : +
  Separating the various functions of our application into their own separate tabs will reduce clutter and enable users to be more organized in their learning.

* Highlights : +
  In line with the _Command Line_ theme, the user is able to switch tabs by typing the command _"tab"_ instead of using a mouse-click.


=== Various commands

|===
| Apart from the exit command, the other commands are extensions of the features described above. They serve as a medium for users to be able to perform functions related to the above features through a  _Command Line_ interface.
|===

. *Tab* +
  * What it does : changes the current tab that the application is showing

. *Submit* +
  * What it does : evaluates the user's solution against the question that he is currently attempting.
. *New Note* +
  * What it does : creates a new note and opens it in the application.
. *Open Note* +
  * What it does : loads an existing  note in the application.
. *Delete Note* +
 * What it does : deletes an existing note
. *Save Note* +
 * What it does : saves changes made to the currently opened note.
. *Exit*
 * What it does : exits the application
 * Highlights : automatically saves any changes that the user has made to his solution and notes before exiting the application.

== Summary of contributions


== Other Contributions

** Project management
*** Managed and enforced branching workflow on GitHub
*** Set up auto-publishing of docs (https://github.com/AY1920S1-CS2103T-F14-1/main/commit/ccde6b5fba8b4d5294678804d0e63c03804ce24c[commit])
*** Managed releases `v1.3` - `v1.4` on GitHub (2 releases)
** Product design:
*** Updated the GUI layout and color scheme (Pull requests https://github.com/AY1920S1-CS2103T-F14-1/main/pull/112[#112])
** Documentation:
*** Cosmetic tweaks to contents of the User Guide (Pull requests https://github.com/AY1920S1-CS2103T-F14-1/main/pull/13[#13] https://github.com/AY1920S1-CS2103T-F14-1/main/pull/34[#34])
*** Actively contributed to the writing of the User Guide and Developer Guide (Pull requests https://github.com/AY1920S1-CS2103T-F14-1/main/pull/77[#77] https://github.com/AY1920S1-CS2103T-F14-1/main/pull/83[#83]  https://github.com/AY1920S1-CS2103T-F14-1/main/pull/185[#185] https://github.com/AY1920S1-CS2103T-F14-1/main/pull/190[#190])
** Testing:
*** Wrote tests to validate the code base (Pull requests https://github.com/AY1920S1-CS2103T-F14-1/main/pull/87[#87] https://github.com/AY1920S1-CS2103T-F14-1/main/pull/88[#88])
*** Actively wrote tests for most major pull requests
** Community:
*** Reported bugs and suggestions for other teams in the class (https://github.com/nus-cs2103-AY1920S1/addressbook-level3/pull/25[Liberry])

== Code Contributions

Click the links below to view my code contributions on RepoSense.
On RepoSense, you can select options to view my functional code and test code.

* https://nus-cs2103-ay1920s1.github.io/tp-dashboard/#search=F14&sort=groupTitle&sortWithin=title&since=2019-09-06&timeframe=commit&mergegroup=false&groupSelect=groupByRepos&breakdown=false&tabOpen=true&tabType=authorship&tabAuthor=limhawjia&tabRepo=AY1920S1-CS2103T-F14-1%2Fmain%5Bmaster%5D[Functional code]
* https://nus-cs2103-ay1920s1.github.io/tp-dashboard/#search=F14&sort=groupTitle&sortWithin=title&since=2019-09-06&timeframe=commit&mergegroup=false&groupSelect=groupByRepos&breakdown=false&tabOpen=true&tabType=authorship&tabAuthor=limhawjia&tabRepo=AY1920S1-CS2103T-F14-1%2Fmain%5Bmaster%5D[Test code]

== Contributions to the User Guide

|===
|_Given below are sections that I contributed to the User Guide. They showcase my ability to write documentation targeting end-users._
|===

include::../UserGuide.adoc[tag=overview]
include::../UserGuide.adoc[tag=beforestart]
include::../UserGuide.adoc[tag=submit]
include::../UserGuide.adoc[tag=notes]

== Contributions to the Developer Guide

|===
|_Given below are sections I contributed to the Developer Guide. They showcase my ability to write technical documentation and the technical depth of my contributions to the project._
|===

include::../DeveloperGuide.adoc[tag=logic]

include::../DeveloperGuide.adoc[tag=programevaluation]

