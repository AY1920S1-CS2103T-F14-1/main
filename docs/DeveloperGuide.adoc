= DukeAcademy - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images/developerguide
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://ay1920s1-cs2103t-f14-1.github.io/main/

By: `Team AY1920S1-CS2103T-F14-1`      Since: `Sept 2019`      Licence: `MIT`

== Setting up

Refer to the guide <<SettingUp#, here>>.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.puml` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder.
Refer to the <<UsingPlantUml#, Using PlantUML guide>> to learn how to create and edit diagrams.

`Main` has two classes called link:{repoURL}/src/main/java/seedu/difficulty/Main.java[`Main`] and link:{repoURL}/src/main/java/seedu/difficulty/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.

The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of six components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: Includes 3 types of executors: the Command Executor, the Program Submission Executor, and the Question Builder Executor,.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.
* <<Design-Observable, *`Observable`*>>:
* <<Design-TextExecutor, *`TextExecutor`*>>: Compile the user program and run it against test cases. Output result.

Each of the six components:

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `QuestionLogic` component (see the class diagram given below) defines it's API in the `QuestionLogic.java` interface and exposes its functionality using the `QuestionLogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[]

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

.Component interactions for `view 1` command
image::ArchitectureSequenceDiagram.png[]

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/difficulty/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/difficulty/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.

//tag::logic[]
[[Design-Logic]]
=== Logic components

==== Overview
There are 4 main logic components found in the architecture of Duke Academy. They are `CommandLogic`, `QuestionsLogic`, `ProgramSubmissionLogic` and `NotesLogic`.
Each logic component serves as a *facade* for the basic operations by the application with regards to *Commands*, *Questions*, *ProgramSubmission* and *Notes*.

They orchestrate the execution of these operations internally and expose a simple interface for other components, such as the `UI` to utilize.

The logic components are interfaces so their implementation can be changed easily.

====
*CommandLogic*:
[[fig-CommandLogicClassDiagram]]
.Class diagram of the CommandLogic interface
image::CommandLogicClassDiagram.png[]

- Only has one method  which is used by the application to execute commands.
====

====
*QuestionsLogic:*
[[fig-QuestionLogicClassDiagram]]
.Class diagram of the QuestionLogic interface
image::QuestionsLogicClassDiagram.png[]
- Deals with all CRUD operations pertaining to the questions found in the application.
- Keeps track a _selected question_ which represents the `Question` that is currently being viewed by the user in the `UI`.
====

====
*ProgramSubmissionLogic:*
[[fig-ProgramSubmissionLogicClassDiagram]]
.Class diagram of the ProgramSubmissionLogic interface
image::ProgramSubmissionLogicClassDiagram.png[]
- Orchestrates the evaluation of the user's program submissions.
- Keeps track of a _currently attempting_ question which is used as the `Question` that user program submissions are tested against.
- Uses the `UserProgramChannel` interface to enable other components such as the `UI` to serve as a source for `UserProgram` submissions without introducing them as dependencies.
====

====
*NotesLogic:*
[[fig-NotesLogicClassDiagram]]
.Class diagram of the NotesLogic interface
image::NotesLogicClassDiagram.png[]

- Deals with all CRUD operations pertaining to the notes found in the application.
- Uses the `NoteSubmissionChannel` interface to enable other components such as the `UI` to serve as a source for notes without introducing them as dependencies.

*Note model:*
[[fig-NoteClassDiagram]]
.Class diagram of the Note class
image::NoteClassDiagram.png[]

- The note model class represents a user's note in the application.
- It contains a *title* which provides an easy way for the user to identify and organize his or her notes
- It contains a *content* string to represent all the text-based notes that the user has entered.
- Each note also contains a *sketch* which the user can draw and edit within the `NoteCanvas` component. The sketch is stored as a png whose file name corresponds to the *sketchId* of the note.

====

==== CommandLogic implementation
The standard implementation of the CommandLogic is the `CommandLogicManager` class.

*Overview:*

[[fig-CommandLogicManagerAssociations]]
.Associations of the CommandLogicManager
image::CommandLogicManager.png[]

- Works by requiring its users to register a `CommandSupplier` functional interface with a specific key.
- `Command` can also be registered with a `CommandFactory` which encapsulates the Key-CommandSupplier relation.

- Subsequent calls to `executeCommand()` will attempt to match the command String to all the registered keys
- Matching key is used to retrieve the correct `CommandSupplier`.

- Storage of these keys and the parsing of the `commandText` argument is performed by `CommandParser`.

====
* `CommandSupplier` only accepts the arguments of the command.
* `InvalidCommandArgumentException` is thrown if the arguments do not match the specification of the command.
* `CommandParser` splits the command String into the registered key and arguments to retrieve the corresponding command.
====

====
[[fig-CommandLogicSequenceDiagram]]
.Sequence diagram for command execution
image::CommandLogicSequence.png[]

*The basic sequence of command execution is as follows:*

. `Command` is registered upon startup by the application driver

. `Command` and matching key is stored in `CommandParser` by `CommandLogicManager`

. User enters command text

. Application driver passes the command text as a String to `CommandLogicManager`

. `CommandLogicManager` passes on command text to `CommandParser` for parsing and `Command` retrieval

. `CommandLogicManager` executes retrieved `Command`
====

==== QuestionsLogic implementation
The standard implementation of the `QuestionsLogic` interface is the `QuestionsLogicManager`. This implementation stores the questions
in the application in the form of a `QuestionBank`. It saves any changes made to the `QuestionBank` immediately using a `QuestionBankStorage`.
_(View <<Design-Storage>> for more details.)_

*Overview:*

[[fig-QuestionsLogicManagerAssociations]]
.Associations of the QuestionLogicManager
image::QuestionsLogicManager.png[]

- `QuestionsLogicManager` allows other components of the application to make changes to the current state of questions using its methods.

- Other components of the application can observe the current state of questions by getting an `ObservableList` of all the questions in the application through `getAllQuestionsList()` and `getFilteredQuestionsList()`.

- `ObservableList` from `getFilteredQuestionsList()` is a filtered list of the questions in the application. This filter can be changed by `setFilter(predicate)`.


====
* The `QuestionsLogicManager` constructor takes in a `QuestionBankStorage` instance which is used to load the initial `QuestionBank` and to save subsequent revisions to it.

* The main bulk of the CRUD operations are handled by the `QuestionBank` class. the `QuestionLogicManager` orchestrate the invocation of the `QuestionBank` methods along with storage of the changes.
====


==== ProgramSubmissionLogic implementation
The standard implementation of the `ProgramSubmissionLogic` is the `ProgramSubmissionLogicManager`. This implementation
relies on the `TestExecutor` class to execute users' program submissions locally on their machine.
_(View <<Implementation-ProgramEvaluation>> for more details.)_

*Overview:*

[[fig-ProgramSubmissionLogicAssociations]]
.Associations of the ProgramSubmissionLogicManager
image::ProgramSubmissionLogicManager.png[]

- ProgramSubmissionLogicManager` works by keeping track of a `Question` that is "currently attempted" by the user. Subsequent calls to `submitUserProgram(userProgram)` or `submitUserProgramFromSubmissionChannel()`
   run the user's program against test cases found in this `Question`.
- Other components can set the "currently attempted" `Question` through the `setCurrentQuestion(question)`.
- Other components can observe the latest `TestResult` through an observable provided by `getTestResultObservable()` without having `ProgramSubmissionLogicManager` depending on them.
- Other components can serve as the source of the user program to be evaluated by `ProgramSubmissionLogicManager`  by providing a functional interface `UserProgramChannel` without the `ProgramSubmissionLogicManager` having to depend on them.

====
* `ProgramSubmissionLogicManager` instantiates the `TestExecutor` using the `StandardCompilerEnvironment`, `StandardCompiler` and `StandardProgramExecutor`.

* `ProgramSubmissionLogicManager` holds a reference to `StandardCompilerEnvironment` so that it can close the environment and delete any temporary files that were created in the `closeSubmissionLogicManager()` method.

* It is *important* that the main app driver closes the `StandardCompilerEnvironment` through the `closeSubmissionLogicManager()` method before the app is exited to remove any temporary files that were created.
====

====
[[fig-ProgramSubmissionSequenceDiagram]]
.Sequence diagram of program submissions
image::ProgramSubmissionSequence.png[]

*The basic sequence of submitting a user's program for evaluation from a `UI`  component is as follows:*

. Register the `UI` component as the new  `UserProgramChannel` of `ProgramSubmissionLogicManager` through `setProgramSubmissionChannel(channel)`.
. Set the _currently attempting_ question using the `setCurrentQuestion(question)` method.
. Invoke the `submitUserProgramFromSubmissionChannel()`.
. User program is retrieved from the `UI` component and evaluated against the test cases of the _currently attempting_ question.
====


==== NotesLogic implementation
The standard implementation of the `NotesLogic` interface is the `NotesLogicManager`. This implementation relies on `SketchManager` to handle the loading and writing of the *Sketch* png image files.
It also stores the notes in the application in the form of a `NoteBank`. It saves any changes made to the `NoteBank` immediately using a `NoteBankStorage`.
_(View <<Design-Storage>> for more details.)_

*Overview:*

[[fig-NotesLogicManagerAssociations]]
.Associations of the NotesLogicManager
image::NotesLogicManager.png[]
- `NotesLogicManager` allows other components of the application to make changes to the current state of notes using its methods.
- Other components of the application can also observe the current state of notes by getting an `ObservableList` of all the questions in the application through `getAllNotesList()`
- Other components can also serve as sources for Notes by providing a `NoteSubmissionChannel` interface without having to introduce them as dependencies.

====
* The `NotesLogicManager` constructor takes in a `NoteBankStorage` instance which is used to load the initial `QuestionBank` and to save subsequent revisions to it.

* The main bulk of the CRUD operations are handled by the `NoteBank` class. the `NotesLogicManager` orchestrate the invocation of the `QuestionBank` methods along with storage of the changes.

* Note that `NoteSubmissionChannels` are required to produce a pair of values -- a `Note` and a `WritableImage` instance to represent the user's sketch for that `Note`.
====

====
*SketchManager:*
[[fig-SketchManagerClassDiagram]]
.Class diagram of the SketchManager
image::SketchManagerClassDiagram.png[]
* Handles the saving, loading and deleting of *sketches*.
* Deals with *sketches* in two formats, `WritableImage` class used by the JavaFX `UI` components for rendering the image, and png form in storage.
* Converts *sketches* between the two formats upon loading/before saving.
====

====
[[fig-NoteSavingSequence]]
.Sequence diagram of saving a note
image::NoteSavingSequence.png[]

*The basic sequence of saving a user's note from a `UI`  component is as follows:*

. Register the `UI` component as the `NoteSubmissionChannel`
. Invoke the `saveNoteFromSubmissionChannel()` method
. `Note` and *sketch* is retrieved from the `NoteSubmissionChannel`
. `Note` is saved by the `NoteBankStorage` while the *sketch* is saved by the `SketchManager`
====
//end::logic[]

[[Design-Model]]
=== Model component


//tag::storage[]

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component for Questions
image::StorageClassDiagram.png[]

*API* :

For Questions, link:{repoURL}/src/main/java/com/dukeacademy/storage/question/QuestionBankStorage.java[`QuestionBankStorage.java`]

For Profile, link: {repoURL}/src/main/java/com/dukeacademy/storage/profile/ProfileStorage.java[`ProfileStorage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Duke Academy question bank in json format and read it back.
* can save the user information in json format and read it back.

//end::storage[]

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `com.dukeacademy.commons` package.

**Core**:

**Exceptions**:

`DataConversionException`: occurs when loading files with incorrect data format.

`IllegalValueException`: occurs when user inputs a invalid command.

**Util**:

`FileUtil`: for loading and saving of files.
`JsonUtil`: for serializing and deserializing json files.

...TBA

== Implementation

This section describes some noteworthy details on how certain features are implemented.

//tag::programevaluation[]
[[Implementation-ProgramEvaluation]]
=== Evaluation of user program submissions
The evaluation of the user's programs is facilitated by the `solutions` package.

==== Entry point

It contains the class `TestExecutor`
which contains a single method `runTestCases(testCases, program)`. This method is used to run a user's program against
a series of test cases.

The method utilizes the classes `TestCase` and `UserProgram` to model the data needed for evaluation.

====
*TestCase* - stores an input and an expected value

[[fig-TestCaseResultClassDiagram]]
.Class diagram for TestCaseResult
image::TestCaseClassDiagram.png[width=240]


*UserProgram* - stores the main class name and the program's source code a String (note that the specified class name
must match the source code for it to be successfully evaluated)

[[fig-UserProgramClassDiagram]]
.Class diagram for UserProgram
image::UserProgramClassDiagram.png[width=240]

====

The result of the evaluation is returned as a `TestResult` object.

====
*TestResult* - encapsulates all the possible outcomes of evaluating the user's program. It is composed of other model
classes -- `TestCaseResult`, `CompileError`.

[[fig-TestResultClassDiagram]]
.Class diagram for TestResult
image::TestResultDiagram.png[]

====

==== Implementation overview

The evaluation of a user's program is done in 3 main steps, each handled by a specialized interface. The 3 steps include:

====
1. Create a Java file inside a temporary directory in the user's file system and writing the user's program to it.

2. Compile that Java file into an executable Java Class file. Catch and store compile errors if any.

3. Execute the main Class file and provide the inputs of the specified test cases. Collect and store any output from the program.

4. Encapsulate the output, errors and results in a model class
====

This is done by `TestExecutor` with the help of three interfaces that are made available through dependency injection --
`CompilerEnvironment`, `Compiler`, `ProgramExecutor`.

Each interface has its specialized role in the evaluation process.
`TestExecutor` acts as an orchestrator to tie all their functionalities together.

====
*CompilerEnvironment* - in charge of creating a temporary folder in the user's file system to create and write Java files.
This temporary folder is deleted after `closed()`. Utilizes the model class `JavaFile`.

[[fig-CompilerEnvironmentAssociations]]
.Associations of CompilerEnvironment
image::CompilerEnvironment.png[]

*Compiler* - in charge of compiling the Java files into Class files at a given file path. Utilizes the model class `ClassFile`.

[[fig-CompilerAssociations]]
.Associations of Compiler
image::Compiler.png[]

*ProgramExecutor* - in charge of executing the compiled Class files. Utilizes the model class `ProgramOutput`.

[[fig-ProgramExecutorAssociations]]
.Associations of ProgramExecutor
image::ProgramExecutor.png[]

*Models:*

* *JavaFile* - contains the canonical name and class path of a Java file with various convenience methods. Note that the file must actually exist or
an `FileNotFoundException` is thrown during instantiation.
* *ClassFile* - contains the canonical name and class path of a Java file with various convenience methods. Note that the file must actually exist or
an `FileNotFoundException` is thrown during instantiation.
* *ProgramInput* - contains the String input to be fed into the user's program.
* *ProgramOutput* - contains the String output produced by the user's program. It also contains convenience methods for producing different outputs.
====


*The basic flow of a program evaluation is as follows:*

. `TestExecutor` calls `clearEnvironment()` of `CompilerEnvironment` to remove any redundant files from previous program
evaluations.

. `TestExecutor` calls `createJavaFile()` of `CompilerEnvironment` to create the Java file with the class name and source code specified
in the `UserProgram` argument.

. `TestExecutor` calls `compileJavaFile()` of `Compiler` to compile the newly created Java file.

. For each test case passed in the argument, `TestExecutor` calls `executeProgram` of `StandardProgramExecutor` with the input from the
test case to retrieve the `CompletableFuture` async task of running the test case.

. `TestExecutor` sets a timeout on the async tasks and maps each `ProgramOutput` received into a `TestCaseResult` model instance.

. `TestExecutor` packs all the data collected from the execution of the test cases into a single `TestResult` instance.

[[fig-TestExecutorSequenceDiagram]]
.Sequence diagram for the evaluation of a user's program
image::TestExecutorSequenceDiagram.png[align:center]

====

Note that if the evaluation `CompletableFuture` async task timesout before it is completed, an errored `TestCaseResult` with a "Time limit exceeded!" error message is returned instead.

Compile errors and runtime errors will also be reflected in the `TestResult` and `TestCaseResult` models respectively.

====

==== Implementation details
The implementations of `CompilerEnvironment`, `Compiler` and `ProgramExecutor` used in the application are as follows:

* *StandardCompilerEnvironment* - this implementation utilizes Java11's native Files library to handle creation, deletion and writing of files.

    - Creates a temporary folder when instantiated at the file path injected through its constructor.

    - All files are created in this temporary folder.

    - The temporary folder is deleted in the `close()` method.

    - When tasked to create a new file, it first creates an empty file in the temporary folder before writing the contents of the user's program to the file

* *StandardCompiler* - this implementation utilizes Java11's native JavaCompiler library to programmatically compile Java files.

    - Compile errors recorded by the `DiagnosticsListener` class from the compilation task is parsed and rethrown as `CompilerException` and `CompileContentException`.
    - `CompilerException` represents compile errors caused by the JavaCompiler library while `CompileContentException` represents errors caused by the user's program.

* *StandardProgramExecutor* - this implementation utilizes Java11's native Runtime class to execute programs programatically.

    - To execute a program, `exec(String command)` of the Runtime instance is called.
    - A command to compile the specified `ClassFile` is generated using its class path and canonical name attributes.
    - The method returns a `Process` instance that executes the program on a separate thread.
    - `StandardProgramExecutor` accesses the input stream of the process and feeds the program the necessary inputs.
    - `StandardProgramExecutor` access the output and error stream of the process and collects any produced output or errors.
    - The process is destroyed and the collected output and errors and packaged as a `ProgramOutput` instance.
//end::programevaluation[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

=== Home Page

The home page of Duke Academy is the main page that the user sees upon app initialization. Not only does it provide an
introduction and greeting to the user, it also functions as a personal dashboard.

As a personal dashboard, it presents the user with essential information about his personal progress and learning
journey.

Here are three main pieces of information presented to the user:
1. Number of questions completed`
2. Questions that user is still working on
3. Questions that user chose to bookmark for personal reference

To obtain these three pieces of information, we first obtain the `ObservableList` that represents all questions in the
storage. We can obtain this `ObservableList`, from `QuestionLogic`, through a method named `getFilteredQuestionsList()`.

The controller class for Home Page, `HomePage.java` has a constructor that takes in this `ObservableList`. Through
helper methods within the controller class, we can do some processing to the `ObservableList` and easily generate the
three pieces of data.

These pieces of information will then be displayed on the Home Page through standard JavaFX controls.

=== Code Result Panel

The code result panel is a panel below the editor that shows the evaluation of the user's program against the specified
test cases in the question.

It takes in a `List` of `TestCaseResults` which contains useful information about how the user's program fared against
the various test cases.

These information are then displayed on the Code Result Panel through standard JavaFX controls.

//tag::problem_description[]
== Problem Description Panel
//end::problem_description[]

== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.

//tag::appendix[]
[appendix]
== Product Scope

*Target user profile*:

* has a need to practice a lot of algorithm / data structure problems with the following conditions satisfied:
+
[none]
** instant assessment of answers submitted
** practices under timed conditions
** automatic progress checker
** personal tutor to recommend problems with suitable difficulties and topics
** fun in learning with achievement badges to unlock
** no WiFi needed,

* or has a need to distribute problem sets:
+
[none]
** can set the coding problems easily
** share problems via link
** view-only answers protected by passwords

* prefer desktop apps over other types
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI apps

*Value proposition*:
[none]
* everyone can learn data structures - anytime, anywhere
* make coding threshold-less
* manage contacts faster than a typical mouse/GUI driven app


[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |student from university courses|search problems by partially matching keywords|identify the problem I am required to do asap

|`* * *` |developer|introduce new problems to the software easily |the repository of code challenges can be updated without much hassle

|`* * *` |coding student|look back on the coding challenges I have completed|revise the concepts used in those problems

|`* * *` |job seeker|view past interview problems by a company|increase my chances of getting hired

|`* * *` |user|see the difficulties of each problem|choose to do problems that are more aligned to my standard

|`* *` |developer|receive detailed auto-generated error reports if any bug occurs|correct them

|`* *` |forgetful user|set reminders|be reminded of the problems that I need to solve before a deadline

|`* *` |unorganized coder|view my progress on different categories|know which area I am weak in

|`* *` |programming course student |attempt problems under timed condition|I feel more prepared in timed assessments such as labs, practical exam and final exam.

|`* *` |tutor|choose to reveal the answers to the solutions through a password|

|`* *` |coder|identify the concepts required to solve a problem before attempting them |move on to another quickly

|`* *` |a coding student|attempt the same problem in different coding languages|test my proficiency at those languages

|`* *` |coding amateur|look at hints/tutorials for the problem|learn something new while attempting a coding challenge

|`* *` |coding student|share coding challenges with my friends easily|discuss possible solutions with them
|`* *` |achievement hunter|view the badges that I have earned (and those that I have not)|feel a sense of accomplishment
|`* *` |conscientious coding student|easily identify problems that I have given up on previously|tackle them again
|`* *` |professor teaching this course|assign a unique hash code for each problem I input|students can look for the problems quickly

|`* *` |picky coder|select different themes for the software|the user interface looks more appealing to me

|`* *` |programming language polyglot|specifically choose problems designed in a specific language|practice that language in focus

|`* *` |coding student|view similar/related problems to the one I have just completed |further deepen my understanding of the concepts used

|`* *` |easily distracted coder|switch off all external distractions|focus better on the problem I am working on

|`* *` |busy coder|save my progress on a problem|come back to it and continue at a later time

|`* *` |competitive programming enthusiast|set my own questions and pose them to my fellow enthusiast friends to solve|

|`* *` | student |see statistics about my attempts/success rates to track my learning progress|

|`*` |tutor|print a pdf version of the coding problem |give them as practices to my students

|`*` |competitive coder|see my areas for improvement after completing a coding challenge|become a better competitive coder

|`*` |international student|view translation of the problem statement|aids my understanding of the problem
|=======================================================================

[appendix]
== Use Cases

(For all use cases below, the *System* is the `Duke Academy` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: UC01 Set questions
*MSS*

1. User requests to input problem sets.
2. Duke Academy requires a file path.
3. User select file path.
4. Duke Academy imports the problem sets and prompts success message.
+
Use case ends.

*Extensions*
[none]
* 4a. The input format is incorrect.
+
Duke Academy reports wrong format error. Duke Academy resumes at step 3.

=== Use case: UC02 View Questions
*MSS*

1. User finds a question by question ID, title or category.
2. Duke Academy shows a list of problems that matches the keyword.
3. User views the question identified by ID.
4. Duke Academy displays the problem statement of the question.
+
Use case ends.

*Extensions*
[none]
* 1a. User inputs wrong keywords.
+
Duke Academy reports error and prompts link to help page.
+
Use case resumes at step 1.

=== Use case: UC03 Attempt Questions
*MSS*

1. User chooses a problem to attempt.
2. Duke Academy shows up the problem statement and an editor.
3. User inputs the code in editor.
4. User submit the answer.
5. Duke Academy compiles the problem and display whether it has passed the test cases.
+
Use case ends.

*Extensions*

[none]
* 2a. User requests to reset the previous input in the editor for this question.
+
[none]
** 2a1. Duke Academy clears the cached code.
+
** Use case resumes from step 3.

* 2b. User requests to set a timer.
+
[none]
** 2b1. Duke Academy requests for a time duration.
** 2b2. User inputs a time duration.
** 2b3. Duke Academy displays a timer.
** 2b4. User starts the timer.
+
Use case resumes from step 4.

* 2c. User requests to quit the program.
+
[none]
** 2c1. Duke Academy requests to save the draft.
** 2c2. User confirms or denies.
** 2c3. Duke Academy follows user's preference to save or discard the draft.
** 2d4. Duke Academy exists.
+
Use case ends.

* *a. At any time, user chooses to attempt an question imported from external resources.
+
[none]
** *a1. load the questions from file.
+
*a2. Duke Academy stores the problem in local machine.
+
*a3. User search for the problem imported.
+
*a4. Duke Academy displays the question.

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  Should be able to hold up to 1000 problem sets without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
. Time taken to assess the submitted programmes should not exceed 3 minutes.
. <<encryption,Data not intended for disclosure>> should be encrypted with minimum needs so that it's protected from direct access.
. Should not take more than 5 seconds to load the initial screen.
. If interrupted, the program should provide an auto-saved version and prompt for restore when the app opens next time.



[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[encryption]] Data not intended for disclosure::
[none]
* User information that is not meant to be shared with others.
* Confidential program sets for technical interviews.
* To prevent plagiarism, input code files intended for graded school assessment.

== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with the Home tab in focus. The questions tab should contain a list of sample questions

=== Attempting question

. Attempting questions

.. Attempt a question
.. Exit the application and reopen it. +
   Expected: The previous attempt should have been saved automatically

. Submitting solutions

.. Attempt a question
.. Submit the solution +
   Expected: The application should run the solution against sample test cases and display the results
.. Submit a solution with a compile error +
   Expected: The application should display the compile error in the Workspace tab
.. Submit a solution with an infinite loop +
   Expected: The evaluation should terminate in 5 seconds and a "Time limit exceeded" error is shown
.. Submit a solution with a runtime error +
   Expected: The application should display the runtime error

=== Creating notes

. Creating notes
.. Create a new note +
   Expected: +
   The new note should be loaded into the Notes tab +
   The sketchpad should be available for drawing +
   The note text input should also be available for editing

. Deleting notes
.. Delete a note +
   Expected: The new note should no longer be reflected in the GUI

. Saving notes
.. Create a new note
.. Edit the note however you like
.. Save the note
.. Restart the app +
   Expected: The changes to the note should be saved and reflected in the app

//end::appendix[]
